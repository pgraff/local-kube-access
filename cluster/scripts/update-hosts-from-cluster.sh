#!/bin/bash
# Script to automatically update /etc/hosts based on actual ingress resources in the cluster
# This ensures /etc/hosts matches what's actually deployed

KUBECONFIG_FILE="$HOME/.kube/config-rke2-cluster.yaml"
HOSTS_FILE="/etc/hosts"
TAILSCALE_DOMAIN="tailc2013b.ts.net"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_header() {
    echo -e "${BLUE}$1${NC}"
}

# Check if running as root
if [ "$EUID" -ne 0 ]; then 
    print_error "This script must be run with sudo"
    echo "Usage: sudo $0"
    exit 1
fi

# Check if kubeconfig exists
if [ ! -f "$KUBECONFIG_FILE" ]; then
    print_error "Kubeconfig file not found at $KUBECONFIG_FILE"
    exit 1
fi

export KUBECONFIG="$KUBECONFIG_FILE"

print_header "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
print_header "  Updating /etc/hosts from Kubernetes Cluster"
print_header "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

# Detect working node IP by testing ingress connectivity
print_status "Detecting node IP with working ingress..."
TEST_HOSTS=$(kubectl get ingress --all-namespaces -o json 2>/dev/null | \
    jq -r '.items[0].spec.rules[0].host' | head -1)

if [ -z "$TEST_HOSTS" ]; then
    TEST_HOSTS="longhorn.tailc2013b.ts.net"
fi

# Get candidate IPs from ingress status
CANDIDATE_IPS=$(kubectl get ingress --all-namespaces -o json 2>/dev/null | \
    jq -r '.items[0].status.loadBalancer.ingress[]?.ip' | \
    sort -u | head -5)

if [ -z "$CANDIDATE_IPS" ]; then
    # Fallback: use storage node IP (known to work)
    print_warning "No ingress IPs in status, using known working storage node IP..."
    NODE_IP="100.111.119.104"
else
    # Test each IP to find one that works
    NODE_IP=""
    for ip in $CANDIDATE_IPS; do
        if timeout 2 curl -s -I -H "Host: $TEST_HOSTS" "http://$ip" >/dev/null 2>&1; then
            HTTP_CODE=$(timeout 2 curl -s -o /dev/null -w "%{http_code}" -H "Host: $TEST_HOSTS" "http://$ip" 2>/dev/null)
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "301" ] || [ "$HTTP_CODE" = "302" ]; then
                NODE_IP="$ip"
                break
            fi
        fi
    done
    
    if [ -z "$NODE_IP" ]; then
        # Fallback to known working IP
        print_warning "Could not detect working IP, using known working storage node IP..."
        NODE_IP="100.111.119.104"
    fi
fi

if [ -z "$NODE_IP" ]; then
    print_error "Could not detect node IP from cluster"
    exit 1
fi

print_status "Using node IP: $NODE_IP"
echo ""

# Get all ingress resources and extract hostnames
print_status "Querying cluster for ingress resources..."
INGRESS_HOSTS=$(kubectl get ingress --all-namespaces -o json 2>/dev/null | \
    jq -r '.items[] | .spec.rules[]? | .host' | \
    grep -E "\.${TAILSCALE_DOMAIN}$" | \
    sort -u)

if [ -z "$INGRESS_HOSTS" ]; then
    print_warning "No ingress resources found with domain $TAILSCALE_DOMAIN"
    echo ""
    print_status "Available ingress resources:"
    kubectl get ingress --all-namespaces -o jsonpath='{range .items[*]}{.metadata.namespace}{"\t"}{.metadata.name}{"\t"}{.spec.rules[*].host}{"\n"}{end}' 2>/dev/null | sort
    exit 1
fi

# Count hosts
HOST_COUNT=$(echo "$INGRESS_HOSTS" | wc -l | tr -d ' ')
print_status "Found $HOST_COUNT ingress host(s) to add to /etc/hosts"
echo ""

# Show what will be added
print_header "Hosts to be added:"
echo "$INGRESS_HOSTS" | while read host; do
    echo "  • $host -> $NODE_IP"
done
echo ""

# Create backup
BACKUP_FILE="${HOSTS_FILE}.backup.$(date +%Y%m%d-%H%M%S)"
cp "$HOSTS_FILE" "$BACKUP_FILE"
print_status "Backed up original hosts file to: $BACKUP_FILE"

# Create temp file
TEMP_FILE=$(mktemp)
cp "$HOSTS_FILE" "$TEMP_FILE"

# Remove existing cluster entries
print_status "Removing existing cluster service entries..."
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS (BSD sed)
    sed -i '' '/# Kubernetes Cluster Service URLs/,/^$/d' "$TEMP_FILE" 2>/dev/null || true
    sed -i '' "/${TAILSCALE_DOMAIN}/d" "$TEMP_FILE" 2>/dev/null || true
else
    # Linux (GNU sed)
    sed -i.bak '/# Kubernetes Cluster Service URLs/,/^$/d' "$TEMP_FILE" 2>/dev/null || true
    sed -i.bak "/${TAILSCALE_DOMAIN}/d" "$TEMP_FILE" 2>/dev/null || true
fi

# Add new entries
print_status "Adding cluster service entries..."
echo "" >> "$TEMP_FILE"
echo "# Kubernetes Cluster Service URLs (via Ingress)" >> "$TEMP_FILE"
echo "# Auto-generated by update-hosts-from-cluster.sh on $(date)" >> "$TEMP_FILE"
echo "# Node IP: $NODE_IP" >> "$TEMP_FILE"

echo "$INGRESS_HOSTS" | while read host; do
    echo "$NODE_IP  $host" >> "$TEMP_FILE"
done

# Replace hosts file
cp "$TEMP_FILE" "$HOSTS_FILE"
rm -f "$TEMP_FILE" "${TEMP_FILE}.bak" 2>/dev/null

print_status "✓ /etc/hosts updated successfully!"
echo ""
print_header "Service URLs now available:"
echo "$INGRESS_HOSTS" | while read host; do
    if [[ "$host" == *"rancher"* ]]; then
        echo "  • https://$host"
    else
        echo "  • http://$host"
    fi
done
echo ""
print_status "Test with: curl -I http://$(echo "$INGRESS_HOSTS" | head -1)"
echo ""

